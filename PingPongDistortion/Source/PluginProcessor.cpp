/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
PingPongDistortionAudioProcessor::PingPongDistortionAudioProcessor()
{
    hasInitialised = false;
}

PingPongDistortionAudioProcessor::~PingPongDistortionAudioProcessor()
{
}

//==============================================================================
const String PingPongDistortionAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int PingPongDistortionAudioProcessor::getNumParameters()
{
    return 0;
}

float PingPongDistortionAudioProcessor::getParameter (int index)
{
    return 0.0f;
}

void PingPongDistortionAudioProcessor::setParameter (int index, float newValue)
{
}

const String PingPongDistortionAudioProcessor::getParameterName (int index)
{
    return String();
}

const String PingPongDistortionAudioProcessor::getParameterText (int index)
{
    return String();
}

const String PingPongDistortionAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String PingPongDistortionAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool PingPongDistortionAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool PingPongDistortionAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool PingPongDistortionAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool PingPongDistortionAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool PingPongDistortionAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double PingPongDistortionAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int PingPongDistortionAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int PingPongDistortionAudioProcessor::getCurrentProgram()
{
    return 0;
}

void PingPongDistortionAudioProcessor::setCurrentProgram (int index)
{
}

const String PingPongDistortionAudioProcessor::getProgramName (int index)
{
    return String();
}

void PingPongDistortionAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void PingPongDistortionAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    numInputChannels = getNumInputChannels();
    numOutputChannels = getNumOutputChannels();
    windowSize = samplesPerBlock;
    gSampleRate = sampleRate;
    
    maxDelaySamples = (int)(sampleRate * (float)upsampleRatio * 1.0); // One second maximum delay
    
    interpolators[0].initialise(sampleRate, 4, samplesPerBlock);
    interpolators[1].initialise(sampleRate, 4, samplesPerBlock);
    
    sampleData = new float[samplesPerBlock*4];
    inputChannelBuffer.setSize(numOutputChannels, samplesPerBlock);
    upSampleBuffer.setSize(numOutputChannels, samplesPerBlock*4);
    // Output from the cross-over networks.
    filterBanks.setSize(numOutputChannels*2, samplesPerBlock*4);
    
    delayLine[0] = new float[maxDelaySamples];
    delayLine[1] = new float[maxDelaySamples];
    for (int i=0; i<maxDelaySamples; i++)
    {
        delayLine[0][i] = 0.0f;
        delayLine[0][i] = 0.0f;
    }
    
    delayTimeSamples[0] = delayTimeSeconds[0]*sampleRate*upsampleRatio;
    delayTimeSamples[1] = delayTimeSeconds[1]*sampleRate*upsampleRatio;
    
    writePointer = 0;
    readPointers[0] = maxDelaySamples-delayTimeSamples[0];
    readPointers[1] = maxDelaySamples-delayTimeSamples[1];
    
    if (!hasInitialised)
    {
        // Space for any one-time initialisation
        
        delayLPCoeffs[0].calculateLowPass(lowPassFrequencies[0], sampleRate*upsampleRatio);
        delayLPCoeffs[1].calculateLowPass(lowPassFrequencies[1], sampleRate*upsampleRatio);
        delayLP[0].updateCoefficients(delayLPCoeffs[0]);
        delayLP[1].updateCoefficients(delayLPCoeffs[1]);
        
        // Initialise the cross-over filters
        crossOverLeftHigh.calculateHighPass(crossOverFrequency[0], sampleRate*upsampleRatio);
        crossOverLeftLow.calculateLowPass(crossOverFrequency[0], sampleRate*upsampleRatio);
        crossOverRightHigh.calculateHighPass(crossOverFrequency[1], sampleRate*upsampleRatio);
        crossOverRightLow.calculateLowPass(crossOverFrequency[1], sampleRate*upsampleRatio);
        
        // Filter index 0 is the bypass and 1 is the delay line feed
        crossOverLeft[0].updateCoefficients(crossOverLeftHigh);
        crossOverLeft[1].updateCoefficients(crossOverRightLow);
        crossOverRight[0].updateCoefficients(crossOverRightHigh);
        crossOverRight[1].updateCoefficients(crossOverRightLow);
        
        hasInitialised = true;
    }
}

void PingPongDistortionAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    interpolators[0].resetFilters();
    interpolators[1].resetFilters();
    if (sampleData != NULL)
        delete[] sampleData;
    if (delayLine[0] != NULL)
        delete[] delayLine[0];
    if (delayLine[1] != NULL)
        delete[] delayLine[1];
    inputChannelBuffer.clear();
    
    delayLP[0].clearZ();
    delayLP[1].clearZ();
    crossOverLeft[0].clearZ();
    crossOverLeft[1].clearZ();
    crossOverRight[0].clearZ();
    crossOverRight[1].clearZ();
}

void PingPongDistortionAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // Convert mono input to stereo output
    if (numInputChannels == 1) {
        inputChannelBuffer.copyFrom(0, 0, buffer.getReadPointer(0), windowSize, preGains[0]);
        inputChannelBuffer.copyFrom(1, 0, buffer.getReadPointer(0), windowSize, preGains[1]);
    } else {
        inputChannelBuffer.copyFrom(0, 0, buffer.getReadPointer(0), windowSize, preGains[0]);
        inputChannelBuffer.copyFrom(1, 0, buffer.getReadPointer(1), windowSize, preGains[1]);
    }
    
    for (int channel = 0; channel<numOutputChannels; channel++)
    {
        interpolators[channel].upsample((float*)inputChannelBuffer.getReadPointer(channel), upSampleBuffer.getWritePointer(channel));
    }
    
    // Filter the interpolated data in the cross-over networks
    
    // copy in the samples to the filter bank.
    long numSamples = upSampleBuffer.getNumSamples();
    filterBanks.copyFrom(0, 0, upSampleBuffer, 0, 0, numSamples);
    filterBanks.copyFrom(1, 0, upSampleBuffer, 0, 0, numSamples);
    filterBanks.copyFrom(2, 0, upSampleBuffer, 1, 0, numSamples);
    filterBanks.copyFrom(3, 0, upSampleBuffer, 1, 0, numSamples);
    
    // Now process each (if needed)
    if (crossOversOn[0])
    {
        // Only process left channel if the cross-over is on
        crossOverLeft[0].processFilter(filterBanks.getWritePointer(0), numSamples, true);
        crossOverLeft[1].processFilter(filterBanks.getWritePointer(1), numSamples, false);
    }
    if (crossOversOn[1])
    {
        // Only process right channel if the cross-over is on
        crossOverRight[0].processFilter(filterBanks.getWritePointer(2), numSamples, true);
        crossOverRight[1].processFilter(filterBanks.getWritePointer(3), numSamples, false);
    }
    
    // Process bypass data
    if (bypassMute[0])
        filterBanks.clear(0, 0, numSamples);
    else
        filterBanks.applyGain(0, 0, numSamples, bypassGains[0]);
    
    if (bypassMute[1])
        filterBanks.clear(2, 0, numSamples);
    else
        filterBanks.applyGain(2, 0, numSamples, bypassGains[1]);
    
    
    
    
    // Upsample Channel Data
    float** channelData = filterBanks.getArrayOfWritePointers();
    for (int n=0; n<windowSize*upsampleRatio; n++) {
        
        float sample[2];
        float storeSample[2];
        // Read channel datas
        sample[0] = delayLine[0][readPointers[0]];
        sample[1] = delayLine[1][readPointers[1]];
        
        storeSample[0] = sample[0];
        storeSample[1] = sample[1];
        
        // Process Distortion
        switch (distortionMode[0]) {
            case 0:
                sample[0] = exponentialDistortion(sample[0], distortionG[0]);
                break;
            case 1:
                sample[0] = sineDistortion(sample[0], distortionG[0]);
                break;
            case 2:
                sample[0] = hardClipping(sample[0], distortionG[0]);
                break;
            case 3:
                sample[0] = halfwaveRectification(sample[0], distortionG[0]);
                break;
            case 4:
                sample[0] = fullWaveRectification(sample[0], distortionG[0]);
                break;
            default:
                sample[0] = halfwaveRectification(sample[0], distortionG[0]);
                break;
        }
        switch (distortionMode[1]) {
            case 0:
                sample[1] = exponentialDistortion(sample[1], distortionG[1]);
                break;
            case 1:
                sample[1] = sineDistortion(sample[1], distortionG[1]);
                break;
            case 2:
                sample[1] = hardClipping(sample[1], distortionG[1]);
                break;
            case 3:
                sample[1] = halfwaveRectification(sample[1], distortionG[1]);
                break;
            case 4:
                sample[1] = fullWaveRectification(sample[1], distortionG[1]);
                break;
            default:
                sample[1] = halfwaveRectification(sample[1], distortionG[1]);
                break;
        }
        
        // Filter the captured samples
        sample[0] = delayLP[0].processSample(sample[0]);
        sample[1] = delayLP[1].processSample(sample[1]);
        
        // Put in new data
        delayLine[0][writePointer] = channelData[1][n];
        delayLine[1][writePointer] = channelData[3][n];
        
        channelData[1][n] = storeSample[0] + channelData[0][n];
        channelData[3][n] = storeSample[1] + channelData[2][n];
        
        // Now add in opposite delays
        delayLine[0][writePointer] += sample[1]* readGains[1];
        delayLine[1][writePointer] += sample[0]* readGains[0];
        
        // Progress Pointers
        writePointer++;
        readPointers[0]++;
        readPointers[1]++;
        if (writePointer >= maxDelaySamples)
            writePointer = 0;
        if (readPointers[0] >= maxDelaySamples)
            readPointers[0] = 0;
        if (readPointers[1] >= maxDelaySamples)
            readPointers[1] = 0;
    }
    
    // Downsample Data
    
    for (int channel = 0; channel<numOutputChannels; channel++)
    {
        interpolators[channel].downsample((float*)filterBanks.getReadPointer(channel*2+1), buffer.getWritePointer(channel));
    }
}

float PingPongDistortionAudioProcessor::exponentialDistortion(float sample, float G)
{
    // Calculate the distortion
    // Equation 7.4: Reiss and McPherson: Page 170
    float sgn;
    if (sample >= 0)
        sgn = 1.0;
    else
        sgn = -1.0;
    
    sample = sgn*(1.0 - expf(-fabsf(G*sample)));
    
    return sample;
}

float PingPongDistortionAudioProcessor::sineDistortion(float sample, float G)
{
    float sgn;
    if (sample >= 0)
        sgn = 1;
    else
        sgn = -1;
    
    return sgn*(1.0 - sinf(-fabsf(G*sample)));
}

float PingPongDistortionAudioProcessor::fullWaveRectification(float sample, float G)
{
    if (sample <= 0.0)
        return sample*-G;
    else
        return sample*G;
}

float PingPongDistortionAudioProcessor::halfwaveRectification(float sample, float G)
{
    sample *= G;
    if (sample <= 0.0)
        sample = 0.0;
    return sample;
}

float PingPongDistortionAudioProcessor::hardClipping(float sample, float G)
{
    sample *= G;
    if (sample >= 1.0)
        return 1.0;
    else if (sample <= -1.0)
        return -1.0;
    return sample;
}

//==============================================================================

float PingPongDistortionAudioProcessor::getDelayTimeSeconds(bool isLeft)
{
    if (isLeft)
        return delayTimeSeconds[0];
    else
        return delayTimeSeconds[1];
}

float PingPongDistortionAudioProcessor::getCrossFeedGains(bool isLeft)
{
    if (isLeft)
        return readGains[0];
    else
        return readGains[1];
}

float PingPongDistortionAudioProcessor::getPreGains(bool isLeft)
{
    if (isLeft)
        return preGains[0];
    else
        return preGains[1];
}

float PingPongDistortionAudioProcessor::getDistortionGain(bool isLeft)
{
    if (isLeft)
        return distortionG[0];
    else
        return distortionG[1];
}

float PingPongDistortionAudioProcessor::getCutoffFrequency(bool isLeft)
{
    if (isLeft)
        return lowPassFrequencies[0];
    else
        return lowPassFrequencies[1];
}

float PingPongDistortionAudioProcessor::getBypassGains(bool isLeft)
{
    if (isLeft)
        return bypassGains[0];
    else
        return bypassGains[1];
}

float PingPongDistortionAudioProcessor::getCrossOverFrequency(bool isLeft)
{
    if (isLeft)
        return crossOverFrequency[0];
    else
        return crossOverFrequency[1];
}

bool PingPongDistortionAudioProcessor::getCrossOverOnState(bool isLeft)
{
    if (isLeft)
        return crossOversOn[0];
    else
        return crossOversOn[1];
}

bool PingPongDistortionAudioProcessor::getDelayMuteState(bool isLeft)
{
    if (isLeft)
        return delayInputMute[0];
    else
        return delayInputMute[1];
}

bool PingPongDistortionAudioProcessor::getBypassMuteState(bool isLeft)
{
    if (isLeft)
        return bypassMute[0];
    else
        return bypassMute[1];
}

int PingPongDistortionAudioProcessor::getDistortionMode(bool isLeft)
{
    if (isLeft)
        return distortionMode[0];
    else
        return distortionMode[1];
}

void PingPongDistortionAudioProcessor::setDelayTimeSeconds(float time, bool isLeft)
{
    if (time >= 0.0) {
        if (isLeft) {
            delayTimeSeconds[0] = time;
            delayTimeSamples[0] = delayTimeSeconds[0]*gSampleRate*upsampleRatio;
            readPointers[0] = (delayTimeSamples[0]+writePointer) % maxDelaySamples;
        } else {
            delayTimeSeconds[1] = time;
            delayTimeSamples[1] = delayTimeSeconds[1]*gSampleRate*upsampleRatio;
            readPointers[1] = (delayTimeSamples[1]+writePointer) % maxDelaySamples;
        }
    }
}

void PingPongDistortionAudioProcessor::setCrossFeedGains(float gain, bool isLeft)
{
    // Set the cross feed gains
    if (gain <= 1.0)
    {
        if(isLeft)
            readGains[0] = gain;
        else
            readGains[1] = gain;
    }
}

void PingPongDistortionAudioProcessor::setPreGains(float gain, bool isLeft)
{
    if (gain <= INFINITY && gain >= -INFINITY)
    {
        if (isLeft)
            preGains[0] = gain;
        else
            preGains[1] = gain;
    }
}

void PingPongDistortionAudioProcessor::setDistortionGains(float gain, bool isLeft)
{
    if (gain >= 1.0)
    {
        if (isLeft)
            distortionG[0] = gain;
        else
            distortionG[1] = gain;
        distortionGRecip[0] = 1.0/distortionG[0];
        distortionGRecip[1] = 1.0/distortionG[1];
    }
}

void PingPongDistortionAudioProcessor::setCutoffFrequency(float freq, bool isLeft)
{
    if (freq >= 20.0 && freq <= 20000.0)
    {
        if (isLeft)
        {
            lowPassFrequencies[0] = freq;
            delayLPCoeffs[0].calculateLowPass(lowPassFrequencies[0], gSampleRate*upsampleRatio);
            delayLP[0].updateCoefficients(delayLPCoeffs[0]);
        } else {
            lowPassFrequencies[1] = freq;
            delayLPCoeffs[1].calculateLowPass(lowPassFrequencies[1], gSampleRate*upsampleRatio);
            delayLP[1].updateCoefficients(delayLPCoeffs[1]); 
        }
    }
}

void PingPongDistortionAudioProcessor::setBypassGains(float gain, bool isLeft)
{
    if (gain >= 0.0)
    {
        if (isLeft)
            bypassGains[0] = gain;
        else
            bypassGains[1] = gain;
    }
}


void PingPongDistortionAudioProcessor::setCrossOverFrequency(float freq, bool isLeft)
{
    if (freq >= 20.0 && freq <= 20000.0)
    {
        if (isLeft)
        {
            crossOverFrequency[0] = freq;
            crossOverLeftHigh.calculateHighPass(freq, gSampleRate*upsampleRatio);
            crossOverLeftLow.calculateLowPass(freq, gSampleRate*upsampleRatio);
            crossOverLeft[0].updateCoefficients(crossOverLeftHigh);
            crossOverLeft[1].updateCoefficients(crossOverLeftLow);
        } else {
            crossOverFrequency[1] = freq;
            crossOverRightHigh.calculateHighPass(freq, gSampleRate*upsampleRatio);
            crossOverRightLow.calculateLowPass(freq, gSampleRate*upsampleRatio);
            crossOverRight[0].updateCoefficients(crossOverRightHigh);
            crossOverRight[1].updateCoefficients(crossOverRightLow);
        }
    }
}

void PingPongDistortionAudioProcessor::setCrossOverState(bool newState, bool isLeft)
{
    if (isLeft)
        crossOversOn[0] = newState;
    else
        crossOversOn[1] = newState;
}

void PingPongDistortionAudioProcessor::setDelayMuteState(bool newState, bool isLeft)
{
    if (isLeft)
        delayInputMute[0] = newState;
    else
        delayInputMute[1] = newState;
}

void PingPongDistortionAudioProcessor::setBypassMuteState(bool newState, bool isLeft)
{
    if (isLeft)
        bypassMute[0] = newState;
    else
        bypassMute[1] = newState;
}

void PingPongDistortionAudioProcessor::setDistortionMode(int newMode, bool isLeft)
{
    if (newMode < 5)
    {
        if (isLeft)
            distortionMode[0] = newMode;
        else
            distortionMode[1] = newMode;
    }
}

//==============================================================================

//==============================================================================
bool PingPongDistortionAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* PingPongDistortionAudioProcessor::createEditor()
{
    return new PingPongDistortionAudioProcessorEditor (*this);
}

//==============================================================================
void PingPongDistortionAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void PingPongDistortionAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PingPongDistortionAudioProcessor();
}
